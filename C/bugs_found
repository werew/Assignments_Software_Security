https://github.com/calccrypto/tar

------

Freeing uninitialized memory:

    void tar_free(struct tar_t * archive){
        while (archive){
            struct tar_t * next = archive -> next;
            free(archive);
            archive = next;
        }
    }

The last `next` pointer of the linked list is never initialized.
Most of the times this happens to be NULL but, if the program would
allocate, write and free some date before the allocation of the 
struct tar_t with uninitialized `next` pointer, it would free
an invalid address != NULL (this address could be controlled by 
an attacker which could exploit in a similar fashion of UAF 
vulnerabilities)



------

Invalid memory access:

    int extract_entry(const int fd, struct tar_t * entry, const char verbosity){
        V_PRINT(stdout, "%s\n", entry -> name);

        if ((entry -> type == REGULAR) || (entry -> type == NORMAL) || (entry -> type == CONTIGUOUS)){
            // create intermediate directories
            size_t len = strlen(entry -> name);
            char * path = calloc(len + 1, sizeof(char));
            strncpy(path, entry -> name, len);

            // remove file from path
            while (--len && (path[len] != '/'));
            path[len] = '\0';   // if nothing was found, path is terminated

If strlen(entry->name) == 0, the program would traverse all the memory looking
for a '/' character. Therefore it will most of the time read or write to invalid memory
raising an exception. Though this bug is hardly exploitable, it can be easily used by an
attacker to crash the program (which could be an interenting DOS scenario in
case of a remote server acception tar archives to unpack)


